<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebCraft - Minecraft Clone</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <style>
        body { margin: 0; overflow: hidden; user-select: none; -webkit-user-select: none; font-family: 'Courier New', monospace; }
        #game-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        .minecraft-btn {
            background-color: #727272;
            border: 2px solid #000;
            border-top-color: #aaa;
            border-left-color: #aaa;
            color: white;
            text-shadow: 2px 2px #000;
            cursor: pointer;
            transition: background 0.1s;
        }
        .minecraft-btn:hover { background-color: #8b8b8b; }
        .minecraft-btn:active { border-top-color: #000; border-left-color: #000; border-bottom-color: #aaa; border-right-color: #aaa; }
        .pixel-text { image-rendering: pixelated; font-smooth: never; }
        
        /* Crosshair */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%); z-index: 10; pointer-events: none;
        }
        
        /* Hotbar */
        .slot { width: 40px; height: 40px; border: 2px solid #555; background: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; }
        .slot.active { border-color: white; border-width: 3px; }
        
        /* Mobile Controls */
        .touch-btn { background: rgba(255,255,255,0.2); border: 2px solid rgba(255,255,255,0.5); border-radius: 8px; font-weight: bold; color: white; display: flex; justify-content: center; align-items: center;}
        
        /* Breaking Animation */
        #break-progress {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 40px; height: 40px; z-index: 9; pointer-events: none; display: none;
        }
        
        .overlay { background: rgba(0,0,0,0.7); }
    </style>
</head>
<body class="bg-black text-white">

    <!-- GAME CANVAS -->
    <canvas id="game-canvas"></canvas>

    <!-- UI LAYER -->
    <div id="ui-layer" class="absolute inset-0 z-20 pointer-events-none hidden">
        
        <!-- CROSSHAIR -->
        <div style="width: 2px; height: 14px; background:white; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);"></div>
        <div style="width: 14px; height: 2px; background:white; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); pointer-events:none;"></div>
        
        <!-- BREAKING PROGRESS -->
        <div id="break-overlay" class="hidden absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-10 h-10 border-2 border-white opacity-50"></div>

        <!-- HUD -->
        <div id="hud" class="absolute bottom-0 w-full flex flex-col items-center pb-4 pointer-events-none">
            <!-- Hearts / Hunger -->
            <div id="stats-bar" class="flex justify-between w-[360px] mb-1 px-1">
                <div id="hearts" class="flex text-red-600 font-bold text-xl" style="text-shadow: 1px 1px 0 #000;">‚ù§‚ù§‚ù§‚ù§‚ù§‚ù§‚ù§‚ù§‚ù§‚ù§</div>
                <div id="hunger" class="flex text-orange-600 font-bold text-xl" style="text-shadow: 1px 1px 0 #000;">üçñüçñüçñüçñüçñüçñüçñüçñüçñüçñ</div>
            </div>
            <!-- Hotbar -->
            <div id="hotbar" class="flex space-x-1 bg-[#222] p-1 border-2 border-gray-600 pointer-events-auto">
                <!-- Slots generated by JS -->
            </div>
            <!-- XP Bar -->
            <div class="w-[360px] h-2 bg-gray-800 mt-1 border border-green-900 relative">
                <div class="h-full bg-green-500 w-0" id="xp-bar"></div>
            </div>
        </div>

        <!-- DEBUG INFO -->
        <div id="debug-info" class="absolute top-2 left-2 text-xs font-mono text-white">
            FPS: <span id="fps-counter">60</span><br>
            XYZ: <span id="coords">0, 0, 0</span>
        </div>
        
        <!-- MOBILE CONTROLS -->
        <div id="mobile-controls" class="hidden pointer-events-auto absolute inset-0">
            <div class="absolute bottom-20 left-4 w-40 h-40 grid grid-cols-3 grid-rows-3 gap-2">
                <div></div><button id="btn-w" class="touch-btn w-full h-full">‚ñ≤</button><div></div>
                <button id="btn-a" class="touch-btn w-full h-full">‚óÄ</button><div></div><button id="btn-d" class="touch-btn w-full h-full">‚ñ∂</button>
                <div></div><button id="btn-s" class="touch-btn w-full h-full">‚ñº</button><div></div>
            </div>
            <div class="absolute bottom-20 right-4 flex flex-col gap-4">
                <button id="btn-jump" class="touch-btn w-16 h-16 rounded-full">JMP</button>
                <button id="btn-hit" class="touch-btn w-16 h-16 rounded-full bg-red-900/50">ATK</button>
                <button id="btn-place" class="touch-btn w-16 h-16 rounded-full bg-blue-900/50">PLC</button>
            </div>
        </div>
        
        <!-- CHAT -->
        <div id="chat-container" class="hidden absolute bottom-20 left-2 w-[500px] pointer-events-auto">
            <div id="chat-history" class="flex flex-col-reverse h-40 overflow-y-auto text-white text-shadow-sm text-sm mb-2 drop-shadow-md bg-black/30 p-2"></div>
            <input type="text" id="chat-input" class="w-full bg-black/50 border border-gray-500 text-white p-2 hidden" placeholder="–í–≤–µ–¥–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É...">
        </div>
    </div>

    <!-- MENUS (Pointer Events Auto) -->
    <div id="menu-layer" class="absolute inset-0 z-30 flex items-center justify-center bg-[#333] bg-cover bg-center">
        <div class="absolute inset-0 bg-black/50 backdrop-blur-sm"></div>
        
        <!-- MAIN MENU -->
        <div id="main-menu" class="relative flex flex-col items-center gap-4 w-80">
            <h1 class="text-6xl font-bold text-white drop-shadow-md mb-8" style="text-shadow: 4px 4px #000;">MINECRAFT</h1>
            <button onclick="showScreen('singleplayer-menu')" class="minecraft-btn w-full py-3 text-lg">–û–¥–∏–Ω–æ—á–Ω–∞—è –∏–≥—Ä–∞</button>
            <button onclick="showScreen('multiplayer-menu')" class="minecraft-btn w-full py-3 text-lg">–ú—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä</button>
            <button onclick="showScreen('settings-menu')" class="minecraft-btn w-full py-3 text-lg">–ù–∞—Å—Ç—Ä–æ–π–∫–∏</button>
            <button onclick="window.close()" class="minecraft-btn w-full py-3 text-lg">–í—ã—Ö–æ–¥ –∏–∑ –∏–≥—Ä—ã</button>
        </div>

        <!-- SINGLEPLAYER MENU -->
        <div id="singleplayer-menu" class="hidden relative flex flex-col items-center gap-4 w-[600px] bg-black/80 p-8 border-2 border-gray-500">
            <h2 class="text-3xl text-white mb-4">–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –º–∏—Ä</h2>
            
            <div class="grid grid-cols-2 gap-4 w-full">
                <div class="flex flex-col gap-2">
                    <label class="text-gray-300">–ù–∞–∑–≤–∞–Ω–∏–µ –º–∏—Ä–∞</label>
                    <input type="text" id="world-name" value="–ù–æ–≤—ã–π –º–∏—Ä" class="p-2 bg-black border border-gray-500 text-white">
                </div>
                <div class="flex flex-col gap-2">
                    <label class="text-gray-300">–°–∏–¥ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏</label>
                    <input type="text" id="world-seed" placeholder="–°–ª—É—á–∞–π–Ω—ã–π" class="p-2 bg-black border border-gray-500 text-white">
                </div>
            </div>

            <div class="grid grid-cols-2 gap-4 w-full mt-4">
                <button id="btn-gamemode" onclick="cycleGamemode()" class="minecraft-btn py-2">–†–µ–∂–∏–º: –í—ã–∂–∏–≤–∞–Ω–∏–µ</button>
                <button id="btn-difficulty" onclick="cycleDifficulty()" class="minecraft-btn py-2">–°–ª–æ–∂–Ω–æ—Å—Ç—å: –ù–æ—Ä–º–∞–ª—å–Ω–æ</button>
                <button id="btn-cheats" onclick="toggleCheats()" class="minecraft-btn py-2">–ß–∏—Ç—ã: –í—ã–∫–ª</button>
                <button onclick="importWorld()" class="minecraft-btn py-2">–ó–∞–≥—Ä—É–∑–∏—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ</button>
            </div>
            
            <p id="mode-desc" class="text-gray-400 text-sm h-10 text-center mt-2">–ü–æ–∏—Å–∫ —Ä–µ—Å—É—Ä—Å–æ–≤, –∫—Ä–∞—Ñ—Ç, –ø–æ–ª—É—á–µ–Ω–∏–µ —É—Ä–æ–≤–Ω—è, –∑–¥–æ—Ä–æ–≤—å–µ –∏ –≥–æ–ª–æ–¥.</p>

            <div class="flex gap-4 w-full mt-6">
                <button onclick="createWorld()" class="minecraft-btn flex-1 py-3">–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –º–∏—Ä</button>
                <button onclick="showScreen('main-menu')" class="minecraft-btn flex-1 py-3">–û—Ç–º–µ–Ω–∞</button>
            </div>
            <input type="file" id="file-input" class="hidden" accept=".json">
        </div>

        <!-- MULTIPLAYER MENU -->
        <div id="multiplayer-menu" class="hidden relative flex flex-col items-center gap-4 w-[600px] bg-black/80 p-8 border-2 border-gray-500 text-center">
            <h2 class="text-3xl text-white mb-4">–ú—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä</h2>
            <div class="w-full h-64 bg-black border border-gray-600 p-2 overflow-y-auto mb-4 text-left">
                <div class="flex justify-between items-center p-2 bg-gray-900 mb-1 cursor-pointer hover:bg-gray-800 border border-gray-700">
                    <div>
                        <div class="text-green-500 font-bold">–û—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã–π –°–µ—Ä–≤–µ—Ä</div>
                        <div class="text-gray-400 text-xs">–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!</div>
                    </div>
                    <div class="text-right">
                        <span class="text-green-500">14/100</span>
                        <div class="text-xs text-gray-500">12ms</div>
                    </div>
                </div>
                <div class="text-gray-500 italic p-2 text-center mt-10">–ü–æ–∏—Å–∫ —Å–µ—Ä–≤–µ—Ä–æ–≤ –ª–æ–∫–∞–ª—å–Ω–æ–π —Å–µ—Ç–∏...</div>
            </div>
            <div class="flex gap-4 w-full">
                <button onclick="joinServer()" class="minecraft-btn flex-1 py-3">–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è</button>
                <button onclick="showScreen('main-menu')" class="minecraft-btn flex-1 py-3">–ù–∞–∑–∞–¥</button>
            </div>
        </div>

        <!-- PAUSE MENU -->
        <div id="pause-menu" class="hidden relative flex flex-col items-center gap-3 w-64 p-4 bg-black/80 border-2 border-gray-500">
            <h2 class="text-2xl text-white mb-2">–ú–µ–Ω—é –ò–≥—Ä—ã</h2>
            <button onclick="resumeGame()" class="minecraft-btn w-full py-2">–í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –∏–≥—Ä—É</button>
            <button onclick="saveWorld()" class="minecraft-btn w-full py-2">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å (JSON)</button>
            <button onclick="saveWorldHTML()" class="minecraft-btn w-full py-2">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å (HTML)</button>
            <button onclick="showScreen('settings-menu')" class="minecraft-btn w-full py-2">–ù–∞—Å—Ç—Ä–æ–π–∫–∏</button>
            <button onclick="quitGame()" class="minecraft-btn w-full py-2">–í—ã–π—Ç–∏ –≤ –º–µ–Ω—é</button>
        </div>
        
        <!-- SETTINGS MENU -->
         <div id="settings-menu" class="hidden relative flex flex-col items-center gap-4 w-[400px] bg-black/80 p-8 border-2 border-gray-500 text-center">
            <h2 class="text-2xl text-white mb-2">–ù–∞—Å—Ç—Ä–æ–π–∫–∏</h2>
            <div class="w-full space-y-2">
                 <button onclick="toggleMobileControls()" class="minecraft-btn w-full py-2">–ú–æ–±–∏–ª—å–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: <span id="mobile-setting">–í—ã–∫–ª</span></button>
                 <button class="minecraft-btn w-full py-2">–ü–æ–ª–µ –∑—Ä–µ–Ω–∏—è: 70</button>
                 <button class="minecraft-btn w-full py-2">–î–∞–ª—å–Ω–æ—Å—Ç—å –ø—Ä–æ—Ä–∏—Å–æ–≤–∫–∏: 8</button>
            </div>
            <button onclick="goBackFromSettings()" class="minecraft-btn w-full py-2 mt-4">–ì–æ—Ç–æ–≤–æ</button>
         </div>

        <!-- CREATIVE INVENTORY -->
        <div id="creative-menu" class="hidden relative bg-[#c6c6c6] w-[600px] h-[400px] border-4 border-[#555] p-2 rounded pointer-events-auto">
             <div class="flex justify-between items-center mb-2 px-2">
                 <span class="font-bold text-black">–ú–µ–Ω—é –¢–≤–æ—Ä—á–µ—Å—Ç–≤–∞</span>
                 <button onclick="closeCreative()" class="text-red-900 font-bold">X</button>
             </div>
             <div class="grid grid-cols-9 gap-1 p-2 h-[300px] overflow-y-auto content-start" id="creative-grid">
                 <!-- Filled by JS -->
             </div>
        </div>

        <!-- DEATH SCREEN -->
        <div id="death-screen" class="hidden relative flex flex-col items-center gap-4 text-center p-8 bg-red-900/50 w-full h-full justify-center">
             <h1 class="text-white text-5xl font-bold drop-shadow-lg">–í—ã –ø–æ–≥–∏–±–ª–∏!</h1>
             <p class="text-gray-200 text-xl" id="death-msg">–°—á–µ—Ç: 0</p>
             <div class="flex gap-4 mt-4" id="respawn-buttons">
                 <button onclick="respawn()" class="minecraft-btn px-6 py-2">–í–æ–∑—Ä–æ–¥–∏—Ç—å—Å—è</button>
                 <button onclick="quitGame()" class="minecraft-btn px-6 py-2">–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</button>
             </div>
             <div id="hardcore-msg" class="hidden text-red-300 font-bold mt-2 text-2xl">–†–µ–∂–∏–º –•–∞—Ä–¥–∫–æ—Ä: –í–æ–∑—Ä–æ–∂–¥–µ–Ω–∏–µ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ.</div>
             <button id="hardcore-quit" class="hidden minecraft-btn px-6 py-2 mt-4" onclick="quitGame()">–í—ã–π—Ç–∏ –≤ –º–µ–Ω—é</button>
        </div>
    </div>

    <!-- GAME SCRIPTS -->
    <script>
        // --- CONSTANTS & GLOBALS ---
        const BLOCK_SIZE = 1;
        const CHUNK_SIZE = 16;
        const WORLD_SIZE = 4; // 4x4 chunks for this demo
        
        // Colors
        const COLORS = {
            grass: 0x567d46, dirt: 0x5d4037, stone: 0x757575, wood: 0x5d4037, leaf: 0x2e7d32,
            sand: 0xe1c699, water: 0x1976d2, bedrock: 0x212121, diamond: 0x00bcd4, gold: 0xffeb3b,
            pig: 0xf06292, cow: 0x3e2723, sheep: 0xffffff, chicken: 0xffffff,
            zombie: 0x2e7d32, skeleton: 0xdddddd, creeper: 0x00ff00
        };
        
        // Blocks DB
        const BLOCKS = [
            { id: 1, name: 'Stone', color: COLORS.stone },
            { id: 2, name: 'Grass', color: COLORS.grass },
            { id: 3, name: 'Dirt', color: COLORS.dirt },
            { id: 4, name: 'Wood', color: COLORS.wood },
            { id: 5, name: 'Leaves', color: COLORS.leaf },
            { id: 6, name: 'Sand', color: COLORS.sand },
            { id: 7, name: 'Planks', color: 0x8d6e63 },
            { id: 8, name: 'Bedrock', color: COLORS.bedrock },
            { id: 9, name: 'Glass', color: 0xaed9e0, opacity: 0.6 },
            { id: 50, name: 'Cow Spawn', color: 0x3e2723, type: 'spawner', mob: 'cow' },
            { id: 51, name: 'Pig Spawn', color: 0xf06292, type: 'spawner', mob: 'pig' },
            { id: 52, name: 'Sheep Spawn', color: 0xffffff, type: 'spawner', mob: 'sheep' },
            { id: 53, name: 'Chicken Spawn', color: 0xaaaaaa, type: 'spawner', mob: 'chicken' },
            { id: 54, name: 'Zombie Spawn', color: 0x1b5e20, type: 'spawner', mob: 'zombie' },
            { id: 55, name: 'Skeleton Spawn', color: 0xdddddd, type: 'spawner', mob: 'skeleton' },
            { id: 56, name: 'Creeper Spawn', color: 0x00ff00, type: 'spawner', mob: 'creeper' },
        ];

        // State
        let scene, camera, renderer, controls;
        let blocks = {}; // Map "x,y,z" -> blockId
        let entities = [];
        let raycaster;
        let isGameActive = false;
        let isPaused = false;
        let gamemode = 'survival'; // survival, creative, hardcore
        let difficulty = 'normal'; // peaceful, normal, hard
        let cheatsEnabled = false;
        let player = { hp: 10, hunger: 10, velocity: new THREE.Vector3(), onGround: false, inventory: [], selectedSlot: 0 };
        let lastTime = performance.now();
        let moveState = { fwd: false, bwd: false, left: false, right: false, jump: false, sprint: false };
        let breakState = { active: false, time: 0, blockPos: null, maxTime: 500 }; // ms
        let loadedWorld = null;

        // --- UI LOGIC ---
        function showScreen(screenId) {
            document.querySelectorAll('#menu-layer > div').forEach(d => {
                if(d.id !== 'ui-layer') d.classList.add('hidden');
            });
            
            if(screenId) {
                 const screen = document.getElementById(screenId);
                 if(screen) screen.classList.remove('hidden');
            }
            
            if (screenId === 'main-menu') {
                if(controls) controls.unlock();
                isGameActive = false;
            }
        }

        let gameModeIdx = 0;
        const gameModes = ['survival', 'creative', 'hardcore'];
        const gameModeNames = ['–í—ã–∂–∏–≤–∞–Ω–∏–µ', '–¢–≤–æ—Ä—á–µ—Å–∫–∏–π', '–•–∞—Ä–¥–∫–æ—Ä'];
        
        function cycleGamemode() {
            gameModeIdx = (gameModeIdx + 1) % 3;
            const mode = gameModes[gameModeIdx];
            document.getElementById('btn-gamemode').innerText = '–†–µ–∂–∏–º: ' + gameModeNames[gameModeIdx];
            
            const btnDiff = document.getElementById('btn-difficulty');
            const btnCheats = document.getElementById('btn-cheats');
            const desc = document.getElementById('mode-desc');

            if (mode === 'hardcore') {
                btnDiff.innerText = '–°–ª–æ–∂–Ω–æ—Å—Ç—å: –°–ª–æ–∂–Ω–∞—è';
                btnDiff.disabled = true;
                btnCheats.innerText = '–ß–∏—Ç—ã: –í—ã–∫–ª';
                btnCheats.disabled = true;
                desc.innerText = '–ö–∞–∫ –≤—ã–∂–∏–≤–∞–Ω–∏–µ, –Ω–æ —Å–ª–æ–∂–Ω–µ–µ. –û–¥–Ω–∞ –∂–∏–∑–Ω—å. –ß–∏—Ç—ã –∑–∞–ø—Ä–µ—â–µ–Ω—ã.';
            } else {
                btnDiff.disabled = false;
                btnCheats.disabled = false;
                if(mode === 'creative') desc.innerText = '–ë–µ—Å—Å–º–µ—Ä—Ç–∏–µ, –ø–æ–ª–µ—Ç—ã, –Ω–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–µ —Ä–µ—Å—É—Ä—Å—ã.';
                else desc.innerText = '–ü–æ–∏—Å–∫ —Ä–µ—Å—É—Ä—Å–æ–≤, –∫—Ä–∞—Ñ—Ç, –∑–¥–æ—Ä–æ–≤—å–µ –∏ –≥–æ–ª–æ–¥.';
            }
        }

        let diffIdx = 1;
        const diffs = ['peaceful', 'normal', 'hard'];
        const diffNames = ['–ú–∏—Ä–Ω–∞—è', '–ù–æ—Ä–º–∞–ª—å–Ω–æ', '–°–ª–æ–∂–Ω–∞—è'];
        function cycleDifficulty() {
            diffIdx = (diffIdx + 1) % 3;
            document.getElementById('btn-difficulty').innerText = '–°–ª–æ–∂–Ω–æ—Å—Ç—å: ' + diffNames[diffIdx];
        }

        function toggleCheats() {
            if(gameModes[gameModeIdx] === 'hardcore') return;
            const btn = document.getElementById('btn-cheats');
            const current = btn.innerText.includes('–í–∫–ª');
            btn.innerText = current ? '–ß–∏—Ç—ã: –í—ã–∫–ª' : '–ß–∏—Ç—ã: –í–∫–ª';
        }

        function toggleMobileControls() {
            const btn = document.getElementById('mobile-setting');
            const isOn = btn.innerText === '–í–∫–ª';
            btn.innerText = isOn ? '–í—ã–∫–ª' : '–í–∫–ª';
            if(!isOn) {
                document.getElementById('mobile-controls').classList.remove('hidden');
            } else {
                document.getElementById('mobile-controls').classList.add('hidden');
            }
        }
        
        function goBackFromSettings() {
             if(isGameActive) showScreen('pause-menu');
             else showScreen('main-menu');
        }

        // --- GAME ENGINE ---
        
        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 10, 60);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('game-canvas'), antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            // Lights
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);
            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(50, 100, 50);
            scene.add(sun);

            // Controls
            controls = new THREE.PointerLockControls(camera, document.body);
            controls.addEventListener('lock', () => {
                isPaused = false;
                document.getElementById('menu-layer').classList.add('hidden');
                document.getElementById('ui-layer').classList.remove('hidden');
            });
            controls.addEventListener('unlock', () => {
                if(isGameActive && player.hp > 0) {
                    isPaused = true;
                    showScreen('pause-menu');
                    document.getElementById('menu-layer').classList.remove('hidden');
                }
            });

            raycaster = new THREE.Raycaster();
            
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);

            initMobileControls();

            // Init Inventory
            initHotbar();
            initCreativeMenu();

            loop();
        }

        function createWorld() {
            // Get Settings
            const name = document.getElementById('world-name').value;
            gamemode = gameModes[gameModeIdx];
            difficulty = gamemode === 'hardcore' ? 'hard' : diffs[diffIdx];
            cheatsEnabled = gamemode === 'hardcore' ? false : document.getElementById('btn-cheats').innerText.includes('–í–∫–ª');
            
            // Reset state
            blocks = {};
            entities.forEach(e => scene.remove(e.mesh));
            entities = [];
            
            // Reset Player
            player.hp = 20; // 10 hearts
            player.hunger = 20;
            player.velocity.set(0,0,0);
            camera.position.set(16, 20, 16);
            
            // Generate Terrain
            generateTerrain();
            
            // Spawn initial mobs
            spawnMob('cow', 18, 20, 18);
            spawnMob('zombie', 22, 20, 22);

            // Start
            isGameActive = true;
            isPaused = false;
            updateHUD();
            
            document.querySelectorAll('#menu-layer > div').forEach(d => d.classList.add('hidden'));
            document.getElementById('ui-layer').classList.remove('hidden');
            
            controls.lock();
        }
        
        // Very simple terrain gen
        function generateTerrain() {
            // Clear old meshes
            while(scene.children.length > 0){ 
                scene.remove(scene.children[0]); 
            }
            // Re-add lights
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);
            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(50, 100, 50);
            scene.add(sun);

            // If loading world
            if(loadedWorld) {
                blocks = loadedWorld.blocks;
                // Rebuild meshes
                for(let key in blocks) {
                    const [x,y,z] = key.split(',').map(Number);
                    addBlockVisual(x,y,z, blocks[key]);
                }
                player.hp = loadedWorld.player.hp;
                camera.position.fromArray(loadedWorld.player.pos);
                loadedWorld = null;
                return;
            }

            // Procedural Gen (Simple Heightmap)
            for(let x=0; x<32; x++) {
                for(let z=0; z<32; z++) {
                    const h = Math.floor(Math.sin(x/5)*2 + Math.cos(z/5)*2) + 5;
                    for(let y=0; y<=h; y++) {
                        let type = 1; // Stone
                        if(y===h) type = 2; // Grass
                        else if(y > h-3) type = 3; // Dirt
                        if(y===0) type = 8; // Bedrock
                        
                        setBlock(x,y,z, type);
                    }
                    // Tree chance
                    if(x>2 && x<30 && z>2 && z<30 && Math.random() < 0.02) {
                        spawnTree(x, h+1, z);
                    }
                }
            }
        }

        function spawnTree(x, y, z) {
            for(let i=0; i<4; i++) setBlock(x, y+i, z, 4); // Wood
            // Leaves
            for(let lx=x-2; lx<=x+2; lx++){
                for(let lz=z-2; lz<=z+2; lz++){
                    for(let ly=y+2; ly<=y+4; ly++){
                         if(Math.abs(lx-x)+Math.abs(lz-z) < 3 && !blocks[`${lx},${ly},${lz}`]) {
                             setBlock(lx, ly, lz, 5);
                         }
                    }
                }
            }
        }

        function setBlock(x,y,z, type) {
            const key = `${x},${y},${z}`;
            if(type === 0) {
                if(blocks[key]) {
                    const mesh = scene.getObjectByName(key);
                    if(mesh) scene.remove(mesh);
                    delete blocks[key];
                }
            } else {
                if(!blocks[key]) {
                    blocks[key] = type;
                    addBlockVisual(x,y,z, type);
                }
            }
        }

        function addBlockVisual(x,y,z, type) {
            const bInfo = BLOCKS.find(b=>b.id===type) || BLOCKS[0];
            const geo = new THREE.BoxGeometry(1,1,1);
            const mat = new THREE.MeshLambertMaterial({ color: bInfo.color, transparent: !!bInfo.opacity, opacity: bInfo.opacity || 1 });
            
            // Add simple border for voxel look
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x,y,z);
            mesh.name = `${x},${y},${z}`;
            
            // Edges
            const edges = new THREE.EdgesGeometry(geo);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 }));
            mesh.add(line);
            
            scene.add(mesh);
        }

        // --- ENTITIES ---
        function spawnMob(type, x, y, z) {
            let color = COLORS.white;
            let w=0.8, h=1.8, d=0.8; // default humanoid
            
            if(type === 'cow') { color = COLORS.cow; w=0.9; h=1.2; d=1.4; }
            else if(type === 'pig') { color = COLORS.pig; w=0.8; h=0.9; d=1.2; }
            else if(type === 'sheep') { color = COLORS.sheep; w=0.9; h=1.2; d=1.4; }
            else if(type === 'chicken') { color = COLORS.chicken; w=0.5; h=0.6; d=0.5; }
            else if(type === 'zombie') { color = COLORS.zombie; }
            else if(type === 'skeleton') { color = COLORS.skeleton; w=0.7; d=0.5; }
            else if(type === 'creeper') { color = COLORS.creeper; }

            const mat = new THREE.MeshLambertMaterial({ color: color });
            
            // Group for the mob
            const mesh = new THREE.Group();
            mesh.position.set(x, y, z);
            
            // Body
            const bodyGeo = new THREE.BoxGeometry(w, h * (type==='creeper'?0.7:0.6), d); 
            const body = new THREE.Mesh(bodyGeo, mat);
            // Center body vertically relative to pivot
            body.position.y = h * 0.4;
            mesh.add(body);
            
            // Head
            const headSize = type === 'chicken' ? 0.3 : 0.6;
            const headGeo = new THREE.BoxGeometry(headSize, headSize, headSize);
            const head = new THREE.Mesh(headGeo, mat);
            head.position.y = h * 0.85;
            if(type === 'creeper') head.position.y = h * 0.8;
            mesh.add(head);

            // Legs (Visual only, simple blocks)
            if(type !== 'creeper' && type !== 'chicken') {
                 // Simple legs
                 const legGeo = new THREE.BoxGeometry(0.2, h*0.4, 0.2);
                 const leg1 = new THREE.Mesh(legGeo, mat); leg1.position.set(-w/4, h*0.2, 0);
                 const leg2 = new THREE.Mesh(legGeo, mat); leg2.position.set(w/4, h*0.2, 0);
                 mesh.add(leg1); mesh.add(leg2);
            } else if(type === 'creeper') {
                 const legGeo = new THREE.BoxGeometry(0.3, h*0.3, 0.3);
                 const leg1 = new THREE.Mesh(legGeo, mat); leg1.position.set(-0.2, h*0.15, 0.2);
                 const leg2 = new THREE.Mesh(legGeo, mat); leg2.position.set(0.2, h*0.15, 0.2);
                 const leg3 = new THREE.Mesh(legGeo, mat); leg3.position.set(-0.2, h*0.15, -0.2);
                 const leg4 = new THREE.Mesh(legGeo, mat); leg4.position.set(0.2, h*0.15, -0.2);
                 mesh.add(leg1); mesh.add(leg2); mesh.add(leg3); mesh.add(leg4);
            }

            scene.add(mesh);
            
            entities.push({
                type: type,
                mesh: mesh,
                hp: 10,
                velocity: new THREE.Vector3(),
                onGround: false,
                lastJump: 0
            });
        }

        // --- GAME LOOP ---
        function loop() {
            requestAnimationFrame(loop);
            
            const now = performance.now();
            const dt = Math.min((now - lastTime) / 1000, 0.1);
            lastTime = now;

            if(isGameActive && !isPaused) {
                updatePhysics(dt);
                updateEntities(dt);
                updateInteraction(dt);
                
                document.getElementById('coords').innerText = `${Math.floor(camera.position.x)}, ${Math.floor(camera.position.y)}, ${Math.floor(camera.position.z)}`;
                document.getElementById('fps-counter').innerText = Math.round(1/dt);
            }

            renderer.render(scene, camera);
        }

        function updatePhysics(dt) {
            if(gamemode === 'creative') {
                // Fly mode simplified
                const speed = 10 * dt;
                if(moveState.fwd) controls.moveForward(speed);
                if(moveState.bwd) controls.moveForward(-speed);
                if(moveState.right) controls.moveRight(speed);
                if(moveState.left) controls.moveRight(-speed);
                if(moveState.jump) camera.position.y += speed;
                if(moveState.sprint) camera.position.y -= speed; // Shift goes down
            } else {
                // Survival Physics
                player.velocity.y -= 25 * dt; // Gravity
                
                const speed = (moveState.sprint ? 8 : 4) * dt;
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                direction.y = 0;
                direction.normalize();
                
                const right = new THREE.Vector3();
                right.crossVectors(camera.up, direction).normalize(); 
                right.crossVectors(direction, camera.up).normalize(); // Fix inverted right/left

                const moveVec = new THREE.Vector3();
                if(moveState.fwd) moveVec.add(direction);
                if(moveState.bwd) moveVec.sub(direction);
                if(moveState.right) moveVec.add(right);
                if(moveState.left) moveVec.sub(right);
                
                if(moveVec.length() > 0) moveVec.normalize().multiplyScalar(speed);
                
                player.velocity.x = moveVec.x;
                player.velocity.z = moveVec.z;

                // Apply Velocity with Collision
                const steps = 5;
                const subDt = dt / steps;
                for(let i=0; i<steps; i++) {
                     // X
                    camera.position.x += player.velocity.x * subDt;
                    if(checkCollision(camera.position)) camera.position.x -= player.velocity.x * subDt;
                    // Z
                    camera.position.z += player.velocity.z * subDt;
                    if(checkCollision(camera.position)) camera.position.z -= player.velocity.z * subDt;
                    // Y
                    camera.position.y += player.velocity.y * subDt;
                    if(checkCollision(camera.position)) {
                        const vY = player.velocity.y;
                        camera.position.y -= player.velocity.y * subDt;
                        player.velocity.y = 0;
                        if(vY < 0) player.onGround = true;
                    } else {
                        player.onGround = false;
                    }
                }
                
                // Fall off map
                if(camera.position.y < -30) hurtPlayer(5);
            }
        }
        
        function checkCollision(pos) {
            // Check bounding box radius 0.3 height 1.8
            const r = 0.3;
            const minX = Math.floor(pos.x - r);
            const maxX = Math.floor(pos.x + r);
            const minY = Math.floor(pos.y - 1.5); // Feet
            const maxY = Math.floor(pos.y + 0.2); // Head
            const minZ = Math.floor(pos.z - r);
            const maxZ = Math.floor(pos.z + r);

            for(let x=minX; x<=maxX; x++){
                for(let y=minY; y<=maxY; y++){
                    for(let z=minZ; z<=maxZ; z++){
                        if(blocks[`${x},${y},${z}`]) return true;
                    }
                }
            }
            return false;
        }

        function updateEntities(dt) {
            entities.forEach((e, idx) => {
                // Simple AI: Move randomly, look at player if close
                e.velocity.y -= 25 * dt;
                
                // Random hop
                if(e.onGround && Math.random() < 0.01) {
                    e.velocity.y = 5;
                    e.velocity.x = (Math.random()-0.5) * 2;
                    e.velocity.z = (Math.random()-0.5) * 2;
                }
                
                // Chase player if Zombie
                if(e.type === 'zombie') {
                    const dist = e.mesh.position.distanceTo(camera.position);
                    if(dist < 10 && dist > 1) {
                         const dir = new THREE.Vector3().subVectors(camera.position, e.mesh.position).normalize();
                         e.velocity.x = dir.x * 2;
                         e.velocity.z = dir.z * 2;
                    }
                    if(dist < 1.5 && gamemode !== 'creative') {
                        hurtPlayer(0.05); // continuous damage
                    }
                }

                // Physics update (simplified for mobs)
                e.mesh.position.y += e.velocity.y * dt;
                if(e.mesh.position.y < 0) { // simple floor
                    const bx = Math.round(e.mesh.position.x);
                    const by = Math.round(e.mesh.position.y);
                    const bz = Math.round(e.mesh.position.z);
                    if(blocks[`${bx},${by},${bz}`] || blocks[`${bx},${by-1},${bz}`]) {
                         if(e.velocity.y < 0) {
                             e.velocity.y = 0;
                             e.onGround = true;
                             e.mesh.position.y = Math.ceil(e.mesh.position.y);
                         }
                    } else {
                         e.onGround = false;
                    }
                }
                e.mesh.position.x += e.velocity.x * dt;
                e.mesh.position.z += e.velocity.z * dt;
            });
        }

        // --- INTERACTION ---
        function updateInteraction(dt) {
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const intersects = raycaster.intersectObjects(scene.children);
            
            const breakOverlay = document.getElementById('break-overlay');

            if (intersects.length > 0 && intersects[0].distance < 5) {
                const target = intersects[0];
                
                // Mobs
                const entIndex = entities.findIndex(e => e.mesh === target.object || e.mesh.children.includes(target.object));
                if(entIndex >= 0) {
                    breakOverlay.style.display = 'none';
                    return; // Can't mine mobs
                }

                // Block Mining
                if(breakState.active) {
                    const bx = Math.round(target.object.position.x);
                    const by = Math.round(target.object.position.y);
                    const bz = Math.round(target.object.position.z);
                    const key = `${bx},${by},${bz}`;
                    
                    // Check Bedrock
                    if(blocks[key] === 8 && gamemode !== 'creative') {
                        return;
                    }
                    
                    if(key !== breakState.blockPos) {
                        breakState.time = 0;
                        breakState.blockPos = key;
                    }

                    breakState.time += dt * 1000;
                    
                    breakOverlay.style.display = 'block';
                    const pct = Math.min(breakState.time / breakState.maxTime, 1);
                    breakOverlay.style.clipPath = `inset(0 ${100-pct*100}% 0 0)`;

                    if(breakState.time >= breakState.maxTime || gamemode === 'creative') {
                        // Drop item in survival
                        if(gamemode !== 'creative') {
                             const brokenId = blocks[key]; // get id before removing
                             addToInventory(brokenId);
                        }
                        setBlock(bx, by, bz, 0);
                        breakState.time = 0;
                        breakOverlay.style.display = 'none';
                    }
                } else {
                    breakOverlay.style.display = 'none';
                    breakState.time = 0;
                }
            } else {
                breakOverlay.style.display = 'none';
                breakState.time = 0;
            }
        }

        function onMouseDown(e) {
            if(!isGameActive || isPaused) return;
            
            if(e.button === 0) { // Left Click
                // Hit Logic
                raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
                const intersects = raycaster.intersectObjects(scene.children, true); 
                if(intersects.length > 0 && intersects[0].distance < 4) {
                    const obj = intersects[0].object;
                    const ent = entities.find(en => en.mesh === obj || en.mesh.children.includes(obj));
                    if(ent) {
                        let dmg = 2; 
                        if(player.velocity.y < 0 && !player.onGround) dmg = 3; 
                        
                        ent.hp -= dmg;
                        const dir = new THREE.Vector3().subVectors(ent.mesh.position, camera.position).normalize();
                        ent.velocity.add(dir.multiplyScalar(5));
                        ent.velocity.y = 3;
                        
                        obj.material.color.setHex(0xff0000);
                        setTimeout(() => obj.material.color.setHex(ent.type==='pig'?COLORS.pig:(ent.type==='cow'?COLORS.cow:COLORS.zombie)), 200);

                        if(ent.hp <= 0) {
                            scene.remove(ent.mesh);
                            entities = entities.filter(e => e !== ent);
                        }
                        return;
                    }
                }
                breakState.active = true;
            } else if(e.button === 2) { // Right Click
                 placeBlock();
            }
        }

        function onMouseUp() {
            breakState.active = false;
            breakState.time = 0;
        }

        function placeBlock() {
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const intersects = raycaster.intersectObjects(scene.children);
            if(intersects.length > 0 && intersects[0].distance < 5) {
                const i = intersects[0];
                const bx = i.object.position.x + i.face.normal.x;
                const by = i.object.position.y + i.face.normal.y;
                const bz = i.object.position.z + i.face.normal.z;
                
                const pBox = new THREE.Box3().setFromCenterAndSize(camera.position, new THREE.Vector3(0.6, 1.8, 0.6));
                const bBox = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(bx,by,bz), new THREE.Vector3(1,1,1));
                if(pBox.intersectsBox(bBox)) return;

                const slot = player.inventory[player.selectedSlot];
                if(slot) {
                    if(slot.type === 'spawner') {
                        spawnMob(slot.mob, bx, by+1, bz);
                    } else {
                        setBlock(bx, by, bz, slot.id);
                    }
                }
            }
        }

        function onKeyDown(e) {
            if(!isGameActive && e.code !== 'Escape') return;

            switch(e.code) {
                case 'KeyW': moveState.fwd = true; break;
                case 'KeyS': moveState.bwd = true; break;
                case 'KeyA': moveState.left = true; break;
                case 'KeyD': moveState.right = true; break;
                case 'Space': 
                    if(gamemode === 'creative') moveState.jump = true;
                    else if(player.onGround) player.velocity.y = 8;
                    break;
                case 'ShiftLeft': moveState.sprint = true; break;
                case 'KeyE': 
                     if(gamemode === 'creative') toggleCreativeMenu();
                     break;
                case 'Escape':
                    if(isGameActive) {
                        controls.unlock();
                    }
                    break;
                case 'Slash':
                    if(cheatsEnabled) {
                        setTimeout(() => { 
                            document.getElementById('chat-container').classList.remove('hidden');
                            document.getElementById('chat-input').classList.remove('hidden');
                            document.getElementById('chat-input').focus();
                            controls.unlock();
                        }, 10);
                    }
                    break;
                case 'Digit1': selectSlot(0); break;
                case 'Digit2': selectSlot(1); break;
                case 'Digit3': selectSlot(2); break;
                case 'Digit4': selectSlot(3); break;
                case 'Digit5': selectSlot(4); break;
                case 'Digit6': selectSlot(5); break;
                case 'Digit7': selectSlot(6); break;
                case 'Digit8': selectSlot(7); break;
                case 'Digit9': selectSlot(8); break;
            }
        }

        function onKeyUp(e) {
            switch(e.code) {
                case 'KeyW': moveState.fwd = false; break;
                case 'KeyS': moveState.bwd = false; break;
                case 'KeyA': moveState.left = false; break;
                case 'KeyD': moveState.right = false; break;
                case 'Space': moveState.jump = false; break;
                case 'ShiftLeft': moveState.sprint = false; break;
            }
        }
        
        // --- MOBILE CONTROLS ---
        function initMobileControls() {
            const bind = (id, key) => {
                const el = document.getElementById(id);
                el.addEventListener('touchstart', (e) => { e.preventDefault(); onKeyDown({code: key}); });
                el.addEventListener('touchend', (e) => { e.preventDefault(); onKeyUp({code: key}); });
            };
            bind('btn-w', 'KeyW'); bind('btn-s', 'KeyS'); bind('btn-a', 'KeyA'); bind('btn-d', 'KeyD');
            bind('btn-jump', 'Space'); 
            
            document.getElementById('btn-hit').addEventListener('touchstart', (e) => {
                e.preventDefault();
                onMouseDown({button: 0});
            });
            document.getElementById('btn-hit').addEventListener('touchend', onMouseUp);

            document.getElementById('btn-place').addEventListener('touchstart', (e) => {
                e.preventDefault();
                placeBlock();
            });
        }

        // --- INVENTORY UI ---
        function initHotbar() {
            const hb = document.getElementById('hotbar');
            hb.innerHTML = '';
            for(let i=0; i<9; i++) {
                const div = document.createElement('div');
                div.className = 'slot';
                div.onclick = () => selectSlot(i);
                hb.appendChild(div);
            }
            player.inventory[0] = BLOCKS[1]; // Grass
            player.inventory[1] = BLOCKS[3]; // Wood
            player.inventory[2] = BLOCKS[0]; // Stone
            updateHotbar();
        }

        function updateHotbar() {
            const slots = document.getElementById('hotbar').children;
            for(let i=0; i<9; i++) {
                slots[i].className = 'slot' + (i === player.selectedSlot ? ' active' : '');
                slots[i].style.backgroundColor = i === player.selectedSlot ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.5)';
                slots[i].innerHTML = '';
                if(player.inventory[i]) {
                     const blockDiv = document.createElement('div');
                     blockDiv.style.width = '24px';
                     blockDiv.style.height = '24px';
                     blockDiv.style.backgroundColor = '#' + player.inventory[i].color.toString(16);
                     blockDiv.style.border = '1px solid white';
                     slots[i].appendChild(blockDiv);
                }
            }
        }

        function selectSlot(idx) {
            player.selectedSlot = idx;
            updateHotbar();
        }

        function addToInventory(id) {
            if(!id) return;
            const block = BLOCKS.find(b => b.id === id);
            if(!block) return;
            
            // Simple inventory: just find first empty slot
            for(let i=0; i<9; i++) {
                if(!player.inventory[i]) {
                    player.inventory[i] = block;
                    updateHotbar();
                    return;
                }
            }
            // If full, maybe replace selected? Nah, just discard for now.
        }

        function initCreativeMenu() {
            const grid = document.getElementById('creative-grid');
            BLOCKS.forEach(b => {
                const div = document.createElement('div');
                div.className = 'w-10 h-10 border-2 border-gray-600 bg-gray-900 cursor-pointer flex justify-center items-center hover:border-white';
                const inner = document.createElement('div');
                inner.style.width = '24px'; inner.style.height = '24px';
                inner.style.backgroundColor = '#' + b.color.toString(16);
                div.appendChild(inner);
                div.onclick = () => {
                    player.inventory[player.selectedSlot] = b;
                    updateHotbar();
                };
                grid.appendChild(div);
            });
        }

        function toggleCreativeMenu() {
            const menu = document.getElementById('creative-menu');
            if(menu.classList.contains('hidden')) {
                menu.classList.remove('hidden');
                document.getElementById('ui-layer').classList.add('z-40'); 
                controls.unlock();
            } else {
                closeCreative();
            }
        }
        
        function closeCreative() {
            document.getElementById('creative-menu').classList.add('hidden');
            controls.lock();
        }

        // --- STATS ---
        function updateHUD() {
            if(gamemode === 'creative') {
                document.getElementById('stats-bar').style.display = 'none';
            } else {
                document.getElementById('stats-bar').style.display = 'flex';
                let hStr = '';
                for(let i=0; i<Math.ceil(player.hp/2); i++) hStr += '‚ù§';
                document.getElementById('hearts').innerText = hStr;
            }
        }

        function hurtPlayer(amount) {
            if(gamemode === 'creative') return;
            player.hp -= amount;
            updateHUD();
            
            // Hit effect
            const ui = document.getElementById('ui-layer');
            ui.style.boxShadow = 'inset 0 0 50px red';
            setTimeout(() => ui.style.boxShadow = 'none', 200);

            if(player.hp <= 0) {
                die();
            }
        }

        function die() {
            isGameActive = false;
            controls.unlock();
            showScreen('death-screen');
            if(gamemode === 'hardcore') {
                document.getElementById('respawn-buttons').classList.add('hidden');
                document.getElementById('hardcore-msg').classList.remove('hidden');
                document.getElementById('hardcore-quit').classList.remove('hidden');
            } else {
                document.getElementById('respawn-buttons').classList.remove('hidden');
                document.getElementById('hardcore-msg').classList.add('hidden');
                document.getElementById('hardcore-quit').classList.add('hidden');
            }
        }

        function respawn() {
            player.hp = 20;
            player.hunger = 20;
            player.velocity.set(0,0,0);
            camera.position.set(16, 20, 16);
            isGameActive = true;
            controls.lock();
            showScreen(null);
            document.getElementById('ui-layer').classList.remove('hidden');
            updateHUD();
        }

        // --- SAVE / LOAD ---
        function getSaveData() {
            return {
                seed: document.getElementById('world-seed').value,
                blocks: blocks,
                player: {
                    pos: camera.position.toArray(),
                    inventory: player.inventory,
                    hp: player.hp
                }
            };
        }

        function saveWorld() {
            const data = getSaveData();
            const json = JSON.stringify(data);
            const blob = new Blob([json], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'webcraft_save.json';
            a.click();
        }

        function saveWorldHTML() {
            const data = getSaveData();
            const json = JSON.stringify(data);
            
            // Create a copy of the current HTML
            let htmlContent = document.documentElement.outerHTML;
            
            // Remove any existing save data script if present (to avoid duplication)
            const regex = /<script id="embedded-save" type="application\/json">[\s\S]*?<\/script>/;
            htmlContent = htmlContent.replace(regex, '');
            
            // Inject new data before the closing body tag
            const injection = `<script id="embedded-save" type="application/json">${json}<\/script>`;
            const closeBodyIndex = htmlContent.lastIndexOf('</body>');
            htmlContent = htmlContent.substring(0, closeBodyIndex) + injection + htmlContent.substring(closeBodyIndex);
            
            const blob = new Blob([htmlContent], {type: 'text/html'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'webcraft_world.html';
            a.click();
        }
        
        function checkForEmbeddedSave() {
            const script = document.getElementById('embedded-save');
            if(script) {
                try {
                    const data = JSON.parse(script.textContent);
                    loadedWorld = data;
                    console.log("Found embedded save data", data);
                    // Automatically go to single player menu and enable the "Load" button visually or auto-load?
                    // The user flow: Open file -> Main Menu -> Single Player -> "Load World (HTML)" button? 
                    // Or just alert the user.
                    // Let's set a flag so when they go to Single Player, it's obvious.
                    setTimeout(() => {
                        alert('–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –≤—Å—Ç—Ä–æ–µ–Ω–Ω–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ! –ù–∞–∂–º–∏—Ç–µ "–ó–∞–≥—Ä—É–∑–∏—Ç—å –º–∏—Ä (JSON/–í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π)", —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å.');
                    }, 500);
                } catch(e) {
                    console.error("Error parsing embedded save", e);
                }
            }
        }

        function importWorld() {
            // If we have loadedWorld from embedded save, use it
            if(loadedWorld) {
                 const useEmbedded = confirm("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤—Å—Ç—Ä–æ–µ–Ω–Ω–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —ç—Ç–æ–≥–æ —Ñ–∞–π–ª–∞?");
                 if(useEmbedded) {
                     alert('–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤—ã–±—Ä–∞–Ω–æ. –ù–∞–∂–º–∏—Ç–µ "–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –º–∏—Ä" –¥–ª—è –∑–∞–ø—É—Å–∫–∞.');
                     return;
                 }
            }
            document.getElementById('file-input').click();
        }
        
        document.getElementById('file-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if(!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                try {
                    loadedWorld = JSON.parse(ev.target.result);
                    alert('–ú–∏—Ä –∑–∞–≥—Ä—É–∂–µ–Ω! –ù–∞–∂–º–∏—Ç–µ "–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –º–∏—Ä" (–∫–Ω–æ–ø–∫–∞ –≤–Ω–∏–∑—É), —á—Ç–æ–±—ã –≤–æ–π—Ç–∏ –≤ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–π –º–∏—Ä.');
                } catch(err) {
                    alert('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞');
                }
            };
            reader.readAsText(file);
        });

        // --- MENU ACTIONS ---
        function quitGame() {
            location.reload();
        }
        
        function resumeGame() {
            showScreen(null);
            document.getElementById('ui-layer').classList.remove('hidden');
            controls.lock();
        }

        function joinServer() {
            alert('–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Å–µ—Ä–≤–µ—Ä—É...');
            setTimeout(() => {
                alert('–û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ —Å–µ—Ä–≤–µ—Ä—É WebSocket. –ë—ç–∫–µ–Ω–¥ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤ —ç—Ç–æ–π –¥–µ–º–æ-–≤–µ—Ä—Å–∏–∏.');
            }, 1000);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- CHAT COMMANDS ---
        const chatInput = document.getElementById('chat-input');
        chatInput.addEventListener('keydown', (e) => {
            if(e.key === 'Enter') {
                const text = chatInput.value;
                chatInput.value = '';
                chatInput.classList.add('hidden');
                controls.lock();
                
                // Process command
                if(text.startsWith('/')) {
                    const parts = text.split(' ');
                    const cmd = parts[0].substring(1);
                    if(cmd === 'gamemode') {
                        if(parts[1] === 'c' || parts[1] === '1') gamemode = 'creative';
                        else if(parts[1] === 's' || parts[1] === '0') gamemode = 'survival';
                        addChat(`–†–µ–∂–∏–º –∏–≥—Ä—ã –∏–∑–º–µ–Ω–µ–Ω –Ω–∞ ${gamemode}`);
                        updateHUD();
                    } else if(cmd === 'time') {
                        addChat('–í—Ä–µ–º—è —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ (–≤–∏–∑—É–∞–ª—å–Ω–æ –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ)');
                    } else {
                        addChat(`–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞: ${cmd}`);
                    }
                } else {
                    addChat(`<–°—Ç–∏–≤> ${text}`);
                }
            }
        });

        function addChat(msg) {
            const hist = document.getElementById('chat-history');
            const line = document.createElement('div');
            line.innerText = msg;
            hist.prepend(line);
        }

        // Start
        init();
        checkForEmbeddedSave();
        showScreen('main-menu');

    </script>
</body>
</html>